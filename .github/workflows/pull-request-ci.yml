name: Java CI on Pull Request

on:
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build, Test, and Generate Coverage Report
        run: mvn -B -DtestFailureIgnore=true clean install

      # NEW: Upload the HTML coverage report as an artifact
      - name: Upload Coverage Dashboard
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-html-report
          path: target/site/jacoco/

      # NEW: Enforce a minimum coverage gate
      - name: Check Coverage Gate
        run: |
          # This script parses the jacoco.csv file for the total instruction coverage
          COVERAGE_MINIMUM=80 # Set your desired minimum coverage percentage here
          
          # Extract the last line of the CSV, which contains the totals
          TOTALS_LINE=$(tail -n 1 target/site/jacoco/jacoco.csv)
          
          # Extract missed and covered instruction counts
          INSTRUCTION_MISSED=$(echo "$TOTALS_LINE" | cut -d',' -f4)
          INSTRUCTION_COVERED=$(echo "$TOTALS_LINE" | cut -d',' -f5)
          
          # Calculate the total instructions and the coverage percentage
          TOTAL_INSTRUCTIONS=$(($INSTRUCTION_MISSED + $INSTRUCTION_COVERED))
          COVERAGE_PERCENTAGE=$(awk "BEGIN {printf \"%.0f\", ($INSTRUCTION_COVERED/$TOTAL_INSTRUCTIONS)*100}")
          
          echo "Total Coverage: ${COVERAGE_PERCENTAGE}%"
          echo "Required Minimum: ${COVERAGE_MINIMUM}%"
          
          if (( $(echo "$COVERAGE_PERCENTAGE < $COVERAGE_MINIMUM" | bc -l) )); then
            echo "Error: Code coverage is below the ${COVERAGE_MINIMUM}% threshold."
            exit 1
          fi
          echo "Success: Code coverage meets the required threshold."

      - name: Summarize test results
        if: always()  # Run even if previous steps fail
        shell: bash
        run: |
          set -euo pipefail
          REPORT_DIR="target/surefire-reports"

          if compgen -G "$REPORT_DIR/TEST-*.xml" > /dev/null; then
            TOTAL=0
            FAILURES=0
            ERRORS=0
            SKIPPED=0
            FAILED_TESTS=()

            for file in $REPORT_DIR/TEST-*.xml; do
              if [ -f "$file" ]; then
                # Extract totals using a robust awk-based approach
                t=$(awk -F'="' '/tests="/ {split($2,b,"\""); print b[1]}' "$file" | head -n1)
                f=$(awk -F'="' '/failures="/ {split($2,b,"\""); print b[1]}' "$file" | head -n1)
                er=$(awk -F'="' '/errors="/ {split($2,b,"\""); print b[1]}' "$file" | head -n1)
                s=$(awk -F'="' '/skipped="/ {split($2,b,"\""); print b[1]}' "$file" | head -n1)

                TOTAL=$((TOTAL + ${t:-0}))
                FAILURES=$((FAILURES + ${f:-0}))
                ERRORS=$((ERRORS + ${er:-0}))
                SKIPPED=$((SKIPPED + ${s:-0}))

                # Collect failed test names from <testcase> elements that contain <failure> or <error>
                FAILED_FROM_FILE=$(awk '/<testcase/ {name=""; if(match($0, /name="([^"]+)"/, m)){name=m[1]} } /<failure>/ {if(name!=""){print name}} /<error>/ {if(name!=""){print name}}' "$file")
                for nm in $FAILED_FROM_FILE; do
                  if [ -n "$nm" ]; then
                    FAILED_TESTS+=("$nm")
                  fi
                done
              fi
            done

            PASSED=$((TOTAL - FAILURES - ERRORS - SKIPPED))

            echo "[INFO] Tests run: ${TOTAL}, Failures: ${FAILURES}, Errors: ${ERRORS}, Skipped: ${SKIPPED}, Time elapsed: N/A"
            if [ ${#FAILED_TESTS[@]} -gt 0 ]; then
              # Print failed test names as a comma-separated list
              printf "FAILED TESTS: "
              first=1
              for t in "${FAILED_TESTS[@]}"; do
                if [ $first -eq 1 ]; then
                  printf "%s" "$t"; first=0
                else
                  printf ",%s" "$t"
                fi
              done
              echo
            fi

            # Expose failed tests as an output variable for potential later steps
            FAILED_LIST=$(printf "%s," "${FAILED_TESTS[@]}"); FAILED_LIST=${FAILED_LIST%,}
            echo "failed_tests=${FAILED_LIST}" >> "$GITHUB_OUTPUT"
          else
            echo "[INFO] No Surefire reports found. Tests may not have run."
            echo "failed_tests=" >> "$GITHUB_OUTPUT"
          fi